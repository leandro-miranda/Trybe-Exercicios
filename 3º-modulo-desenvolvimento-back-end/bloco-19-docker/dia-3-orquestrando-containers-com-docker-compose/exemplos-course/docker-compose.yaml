# image: especifica uma imagem Docker pronta, seja local ou a ser baixada no Docker Hub;
# build: especifica a pasta contendo um arquivo Dockerfile a partir do qual o Compose vai executar o comando docker build automaticamente.
version: '3'
services:
  frontend:
    build: frontend/ # Especificamos o contexto, ou seja, a pasta onde est√° o Dockerfile.
    restart: always
    ports:
      - 3000:3000
    depends_on:
      - backend
    volumes:
      - ./logs:/var/log/frontend
    networks:
      - rede-virtual-1
  backend:
    build: backend/ # Especificamos o contexto, ou seja, a pasta onde est√° o Dockerfile.
    restart: always
    ports:
      - 3001:3001
      # o primeiro par√¢metro √© sempre a porta do computador local e o segundo par√¢metro √© a porta exposta no container.
    environment: # vari√°veis de ambiente
      - DB_HOST=database
    depends_on:
      - database
    networks:
      - rede-virtual-1
      - rede-virtual-2
  database:
    image: betrybe/docker-compose-example-database:v1 # Especificamos a Imagem Docker diretamente.
    restart: always
    volumes:
      - dados-do-banco:/data/db # Por que mapeamos o caminho "/data/db"? ü§î como este banco de dados √© um MongoDB, seus dados s√£o armazenados nesta pasta espec√≠fica, segundo sua documenta√ß√£o.
    networks:
      - rede-virtual-2

volumes:
  dados-do-banco:

networks:
  rede-virtual-1:
  rede-virtual-2:

# No final do arquivo existe uma nova chave de primeiro n√≠vel networks:
# Em cada linha declaramos o nome de uma nova rede virtual;
# As redes virtuais permitem criar isolamento entre os servi√ßos;
# Ao utilizar esta chave, o Compose n√£o vai mais criar a rede virtual padr√£o, como estava fazendo antes!
# Dentro de cada servi√ßo, tamb√©m temos a nova chave networks:
# Para o front-end, declaramos que ele est√° presente na rede-virtual-1;
# Para o back-end, declaramos que ele est√° presente na rede-virtual-2 e na rede-virtual-2;
# Para o database, declaramos que ele est√° presente na rede-virtual-2
